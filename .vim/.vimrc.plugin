let g:user_emmet_leader_key='<c-e>'

"""""""""""""""""""""""""""""""
"VimFiler設定
"""""""""""""""""""""""""""""""
vnoremap <silent> p "0p<CR>
"""""""""""""""""""""""""""""""

"""""""""""""""""""""""""""""""
"" 最後のカーソル位置を復元する
"""""""""""""""""""""""""""""""
if has("autocmd")
	autocmd BufReadPost *
				\ if line("'\"") > 0 && line ("'\"") <= line("$") |
				\   exe "normal! g'\"" |
				\ endif
endif
""""""""""""""""""""""""""""""
if $SHELL =~ 'fish'
	set shell=/bin/sh
endif

""""""""""""""""""""""""""""""
"補完機能拡張
""""""""""""""""""""""""""""""
"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
			\ 'default' : '',
			\ 'vimshell' : $HOME.'/.vimshell_hist',
			\ 'scheme' : $HOME.'/.gosh_completions'
			\ }

if !exists('g:neocomplete#keyword_patterns')
	let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

inoremap <expr><C-g>     neocomplete#undo_completion()

inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
	return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
endfunction
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

if !exists('g:neocomplete#sources#omni#input_patterns')
	let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

""""""""""""""""""""""""""""""
" lightline.vim
""""""""""""""""""""""""""""""

let g:mline_bufhist_enable = 1
set laststatus=2
command! Btoggle :let g:mline_bufhist_enable = g:mline_bufhist_enable ? 0 : 1 | :redrawstatus!

let g:lightline = {
			\ 'colorscheme': 'wombat',
			\ 'mode_map': {'c': 'NORMAL'},
			\ 'active': {
			\   'left': [
			\     ['message','mode', 'paste'],
			\     ['fugitive', 'gitgutter', 'filename'],
			\   ],
			\   'right': [
			\     ['lineinfo', 'syntastic'],
			\     ['percent'],
			\     ['fileencoding', 'filetype'],
			\   ]
			\ },
			\ 'component': {
			\   'message': '黒髪ロング清楚'
			\ },
			\   'component_expand': {
			\     'syntastic': 'SyntasticStatuslineFlag'
			\   },
			\   'component_type': {
			\     'syntastic': 'error'
			\   },
			\ 'component_function': {
			\   'modified': 'MyModified',
			\   'readonly': 'MyReadonly',
			\   'fugitive': 'MyFugitive',
			\   'filename': 'MyFilename',
			\   'fileformat': 'MyFileformat',
			\   'mode': 'MyMode',
			\   'syntastic': 'SyntasticStatuslineFlag',
			\   'charcode': 'MyCharCode',
			\   'gitgutter': 'MyGitGutter',
			\ },
			\ 'separator': {'left': '', 'right': ''},
			\ 'subseparator': {'left': '', 'right': ''}
			\ }
function! LightLineHello()
	if winwidth(0) > 70
		return 'Hello, world!'
	else
		return ''
	endif
endfunction

function! LightLineMode()
	return  &ft == 'unite' ? 'Unite' :
				\ &ft == 'vimfiler' ? 'VimFiler' :
				\ &ft == 'vimshell' ? 'VimShell' :
				\ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! MyModified()
	return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
	return &ft !~? 'help\|vimfiler\|gundo' && &ro ? '' : ''
endfunction

function! MyFilename()
	return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
				\ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
				\  &ft == 'unite' ? unite#get_status_string() :
				\  &ft == 'vimshell' ? substitute(b:vimshell.current_dir,expand('~'),'~','') :
				\ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
				\ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
	try
		if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
			let _ = fugitive#head()
      return strlen(_) ? '⭠ '._ : ''
		endif
	catch
	endtry
	return ''
endfunction

function! MyFileformat()
	return winwidth('.') > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
	return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
	return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
	return winwidth('.') > 60 ? lightline#mode() : ''
endfunction

function! MyGitGutter()
	if ! exists('*GitGutterGetHunkSummary')
				\ || ! get(g:, 'gitgutter_enabled', 0)
				\ || winwidth('.') <= 90
		return ''
	endif
	let symbols = [
				\ g:gitgutter_sign_added . ' ',
				\ g:gitgutter_sign_modified . ' ',
				\ g:gitgutter_sign_removed . ' '
				\ ]
	let hunks = GitGutterGetHunkSummary()
	let ret = []
	for i in [0, 1, 2]
		if hunks[i] > 0
			call add(ret, symbols[i] . hunks[i])
		endif
	endfor
	return join(ret, ' ')
endfunction

" https://github.com/Lokaltog/vim-powerline/blob/develop/autoload/Powerline/Functions.vim
function! MyCharCode()
	if winwidth('.') <= 70
		return ''
	endif

	" Get the output of :ascii
	redir => ascii
	silent! ascii
	redir END

	if match(ascii, 'NUL') != -1
		return 'NUL'
	endif

	" Zero pad hex values
	let nrformat = '0x%02x'

	let encoding = (&fenc == '' ? &enc : &fenc)

	if encoding == 'utf-8'
		" Zero pad with 4 zeroes in unicode files
		let nrformat = '0x%04x'
	endif

	" Get the character and the numeric value from the return value of :ascii
	" This matches the two first pieces of the return value, e.g.
	" "<F>  70" => char: 'F', nr: '70'
	let [str, char, nr; rest] = matchlist(ascii, '\v\<(.{-1,})\>\s*([0-9]+)')

	" Format the numeric value
	let nr = printf(nrformat, nr)

	return "'". char ."' ". nr
endfunction
""""""""""""""""""""""""""""""

"-------------------------------------
" previmの設定
" -------------------------------------
let g:previm_enable_realtime = 1

"-------------------------------------
" switch.vim
"-------------------------------------
let g:variable_style_switch_definitions = [
\   {
\     't': {
\       'true': 'false'
\     },
\
\     'f': {
\       'false': 'true'
\     },
\   }
\ ]
nnoremap - :Switch<cr>

nnoremap ! :Switch<CR>

autocmd FileType ruby,eruby,haml let b:switch_custom_definitions = [
    \       ['if', 'unless'],
    \       ['while', 'until'],
    \       ['.blank?', '.present?'],
    \       ['include', 'extend'],
    \       ['class', 'module'],
    \       ['.inject', '.delete_if'],
    \       ['.map', '.map!'],
    \       ['attr_accessor', 'attr_reader', 'attr_writer'],
    \       [100, ':continue', ':information'],
    \       [101, ':switching_protocols'],
    \       [102, ':processing'],
    \       [200, ':ok', ':success'],
    \       [201, ':created'],
    \       [202, ':accepted'],
    \       [203, ':non_authoritative_information'],
    \       [204, ':no_content'],
    \       [205, ':reset_content'],
    \       [206, ':partial_content'],
    \       [207, ':multi_status'],
    \       [208, ':already_reported'],
    \       [226, ':im_used'],
    \       [300, ':multiple_choices'],
    \       [301, ':moved_permanently'],
    \       [302, ':found'],
    \       [303, ':see_other'],
    \       [304, ':not_modified'],
    \       [305, ':use_proxy'],
    \       [306, ':reserved'],
    \       [307, ':temporary_redirect'],
    \       [308, ':permanent_redirect'],
    \       [400, ':bad_request'],
    \       [401, ':unauthorized'],
    \       [402, ':payment_required'],
    \       [403, ':forbidden'],
    \       [404, ':not_found'],
    \       [405, ':method_not_allowed'],
    \       [406, ':not_acceptable'],
    \       [407, ':proxy_authentication_required'],
    \       [408, ':request_timeout'],
    \       [409, ':conflict'],
    \       [410, ':gone'],
    \       [411, ':length_required'],
    \       [412, ':precondition_failed'],
    \       [413, ':request_entity_too_large'],
    \       [414, ':request_uri_too_long'],
    \       [415, ':unsupported_media_type'],
    \       [416, ':requested_range_not_satisfiable'],
    \       [417, ':expectation_failed'],
    \       [422, ':unprocessable_entity'],
    \       [423, ':precondition_required'],
    \       [424, ':too_many_requests'],
    \       [426, ':request_header_fields_too_large'],
    \       [500, ':internal_server_error'],
    \       [501, ':not_implemented'],
    \       [502, ':bad_gateway'],
    \       [503, ':service_unavailable'],
    \       [504, ':gateway_timeout'],
    \       [505, ':http_version_not_supported'],
    \       [506, ':variant_also_negotiates'],
    \       [507, ':insufficient_storage'],
    \       [508, ':loop_detected'],
    \       [510, ':not_extended'],
    \       [511, ':network_authentication_required'],
    \ ]

""""""""""""""""""""""""""""""

autocmd BufNewFile,BufRead *.ejs set filetype=ejs
autocmd BufNewFile,BufRead *._ejs set filetype=ejs

function! s:DetectEjs()
    if getline(1) =~ '^#!.*\<ejs\>'
        set filetype=ejs
    endif
endfunction

autocmd BufNewFile,BufRead * call s:DetectEjs()


augroup MyXML
  autocmd!
  autocmd Filetype xml inoremap <buffer> </ </<C-x><C-o>
  autocmd Filetype html inoremap <buffer> </ </<C-x><C-o>
augroup END

""""""""""""""""""""""""""""""
" NeoSnippet "
""""""""""""""""""""""""""""""
let g:neosnippet#snippets_directory='~/.vim/NeoSnippets/'
""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""
" go-vim "
""""""""""""""""""""""""""""""
runtime.Gosched()
autocmd FileType qf wincmd J
""""""""""""""""""""""""""""""


""""""""""""""""""""""""""""""
" vim-fugitive "
""""""""""""""""""""""""""""""
autocmd QuickFixCmdPost *grep* cwindow

" ステータス行に現在のgitブランチを表示する
set statusline+=%{fugitive#statusline()}"
""""""""""""""""""""""""""""""


""""""""""""""""""""""""""""""
" Unite "
""""""""""""""""""""""""""""""

"unite prefix key.
nnoremap [unite] <Nop>
nmap <Space>f [unite]
 
"unite general settings
"インサートモードで開始
let g:unite_enable_start_insert = 0
"最近開いたファイル履歴の保存数
let g:unite_source_file_mru_limit = 50
 
"file_mruの表示フォーマットを指定。空にすると表示スピードが高速化される
let g:unite_source_file_mru_filename_format = ''
 
nnoremap <silent> <Space>b :<C-u>Unite buffer<CR>
" ファイル一覧
nnoremap <silent> <Space>f :<C-u>UniteWithBufferDir -buffer-name=dotfiles file<CR>
" " レジスタ一覧
nnoremap <silent> <Space>r :<C-u>Unite -buffer-name=register register<CR>
" " 最近使用したファイル一覧
nnoremap <silent> <Space>m :<C-u>Unite file_mru<CR>

" ファイルを開くときの動作
au FileType unite nnoremap <silent> <buffer> <expr> a unite#do_action('split')
au FileType unite inoremap <silent> <buffer> <expr> a unite#do_action('split')
au FileType unite nnoremap <silent> <buffer> <expr> s unite#do_action('vsplit')
au FileType unite inoremap <silent> <buffer> <expr> s unite#do_action('vsplit')

let g:giti_git_command = executable('hub') ? 'hub' : 'git'
nnoremap <silent>gm :Gcommit<CR>
nnoremap <silent>gM :Gcommit --amend<CR>
nnoremap <silent>gb :Gblame<CR>
nnoremap <silent>gB :Gbrowse<CR>

let g:fugitive_git_executable = executable('hub') ? 'hub' : 'git'
nnoremap <silent>gs :Unite giti/status -horizontal<CR>
nnoremap <silent>gl :Unite giti/log -horizontal<CR>
nnoremap <silent>gh :Unite giti/branch_all<CR>

" vim-unite-giti {{{
" `:Unite giti/status`, `:Unite giti/branch`, ` :Unite giti/log`などを起動した
" 後に、各コマンドに合わせた設定を反映します
augroup UniteCommand
  autocmd!
  autocmd FileType unite call <SID>unite_settings()
augroup END

function! s:unite_settings() "{{{
  for source in unite#get_current_unite().sources
    let source_name = substitute(source.name, '[-/]', '_', 'g')
    if !empty(source_name) && has_key(s:unite_hooks, source_name)
      call s:unite_hooks[source_name]()
    endif
  endfor
endfunction"}}}

let s:unite_hooks = {}

function! s:unite_hooks.giti_status() "{{{
  nnoremap <silent><buffer><expr>gM unite#do_action('ammend')
  nnoremap <silent><buffer><expr>gm unite#do_action('commit')
  nnoremap <silent><buffer><expr>ga unite#do_action('stage')
  nnoremap <silent><buffer><expr>gc unite#do_action('checkout')
  nnoremap <silent><buffer><expr>gd unite#do_action('diff')
  nnoremap <silent><buffer><expr>gu unite#do_action('unstage')
endfunction"}}}

function! s:unite_hooks.giti_branch() "{{{
  nnoremap <silent><buffer><expr>d unite#do_action('delete')
  nnoremap <silent><buffer><expr>d unite#do_action('delete_force')
  nnoremap <silent><buffer><expr>rd unite#do_action('delete_remote')
  nnoremap <silent><buffer><expr>rD unite#do_action('delete_remote_force')
endfunction"}}}

function! s:unite_hooks.giti_branch_all() "{{{
  call self.giti_branch()
endfunction"}}}

" insert modeで開始
let g:unite_enable_start_insert = 1

" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1

" grep検索
nnoremap <silent> ,g :<C-u>Unite giti/grep:. -buffer-name=search-buffer<CR>

" カーソル位置の単語をgrep検索
nnoremap <silent> ,cg :<C-u>Unite giti/grep:. -buffer-name=search-buffer<CR><C-R><C-W>

" grep検索結果の再呼出
nnoremap <silent> ,r :<C-u>UniteResume search-buffer<CR>

" unite grep に ag(The Silver Searcher) を使う
 if executable('ag')
   let g:unite_source_grep_command = 'ag'
   let g:unite_source_grep_default_opts = '--nogroup --nocolor --column'
   let g:unite_source_grep_recursive_opt = ''
 endif

